name: ingestao-continuada

on:
  schedule:
    - cron: "15 * * * *"   # roda 15 min de cada hora
  workflow_dispatch:

jobs:
  run:
    runs-on: ubuntu-latest
    timeout-minutes: 50
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-python@v5
        with:
          python-version: "3.11"
      - name: Ingestão contínua
        env:
          WC_BASE: "https://ctctech.store"
          WC_CK: ${{ secrets.WC_CK }}
          WC_CS: ${{ secrets.WC_CS }}
        run: |
          python - <<'PY'
          import os, re, time, json, random, html, urllib.parse, requests

          WC_BASE = os.environ["WC_BASE"].rstrip("/")
          CK = os.environ["WC_CK"]
          CS = os.environ["WC_CS"]

          UA = "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/121 Safari/537.36"
          HDRS = [{"User-Agent": UA, "Accept-Language":"pt-BR,pt;q=0.9"}]

          QUERIES = [
            "produto afiliado eletrônico", "headset gamer", "smartwatch promoção",
            "fone bluetooth tws", "mini projetor", "caixa de som portátil"
          ]

          DOMAINS = [r"amazon\.(com|com\.br)", r"mercadolivre\.(com|com\.br)",
                     r"shopee\.(com|com\.br)", r"shein\.(com|com\.br)"]
          dom_re = re.compile(r"https?://[^\s\"'<>\)]+", re.I)

          def good(u:str)->bool:
            u = u.lower()
            bad = ["accounts.","login","cart","checkout","track","seller","support","help","mailto:"]
            if any(b in u for b in bad): return False
            return any(re.search(d,u) for d in DOMAINS)

          def search_links(q:str):
            out=[]
            for engine in ["https://www.bing.com/search?q=","https://www.google.com/search?q="]:
              url = engine + urllib.parse.quote(q + " site:amazon.com.br OR site:mercadolivre.com.br OR site:shopee.com.br OR site:shein.com")
              try:
                r = requests.get(url, headers=HDRS[0], timeout=20)
                for m in dom_re.findall(r.text):
                  if good(m): out.append(m)
              except Exception: pass
              time.sleep(1.0)
            return list(dict.fromkeys(out))

          def fetch_meta(u:str):
            try:
              r = requests.get(u, headers=HDRS[0], timeout=30)
              t = r.text
            except Exception:
              return {}
            def find(rex, default=""):
              m = re.search(rex, t, re.I|re.S)
              return html.unescape(m.group(1)).strip() if m else default

            title = find(r'<meta[^>]+property=["\']og:title["\'][^>]+content=["\']([^"\']+)["\']')
            if not title:
              m = re.search(r"<title[^>]*>([^<]{3,120})</title>", t, re.I|re.S)
              title = html.unescape(m.group(1)).strip() if m else ""
            desc  = find(r'<meta[^>]+name=["\']description["\'][^>]+content=["\']([^"\']+)["\']')
            price = ""
            for rx in [r'content=["\']R\$\s*([0-9\.,]+)["\']', r'R\$\s*([0-9\.,]{3,})']:
              m = re.search(rx, t, re.I)
              if m: price = m.group(1); break
            img   = find(r'<meta[^>]+property=["\']og:image["\'][^>]+content=["\']([^"\']+)["\']')

            return {"title": title[:120], "description": desc[:800], "price": price, "image": img}

          def create_product(src_url:str, meta:dict):
            name = meta.get("title") or "Produto Afiliado"
            desc = meta.get("description") or ""
            img  = meta.get("image") or ""
            data = {
              "name": name,
              "type": "external",
              "status": "publish",
              "regular_price": "",
              "external_url": src_url,
              "button_text": "Ver oferta",
              "short_description": desc,
              "categories": [{"id": 40}],  # ajuste se quiser
            }
            if img:
              data["images"] = [{"src": img}]
            if meta.get("price"):
              # WooCommerce espera número com ponto
              p = meta["price"].replace(".","").replace(",",".")
              try:
                float(p)
                data["regular_price"] = p
              except: pass

            try:
              r = requests.post(
                f"{WC_BASE}/wp-json/wc/v3/products",
                auth=(CK, CS),
                headers={"User-Agent": UA, "Content-Type":"application/json"},
                data=json.dumps(data), timeout=40)
              return r.status_code in (200,201), r.text
            except Exception as e:
              return False, str(e)

          random.shuffle(QUERIES)
          max_per_run = 5
          created = 0
          seen=set()

          for q in QUERIES:
            links = search_links(q)
            for u in links:
              if u in seen: continue
              seen.add(u)
              if created>=max_per_run: break
              meta = fetch_meta(u)
              ok, msg = create_product(u, meta)
              if ok: created += 1
              time.sleep(random.uniform(0.8, 1.8))
            if created>=max_per_run: break

          print(json.dumps({"created_this_run": created, "attempted": len(seen)}, ensure_ascii=False))
          PY
