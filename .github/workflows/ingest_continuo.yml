name: ingestao-continuada

on:
  schedule:
    - cron: "15 * * * *"   # roda ~a cada hora
  workflow_dispatch:

jobs:
  run:
    runs-on: ubuntu-latest
    timeout-minutes: 50
    steps:
      - uses: actions/checkout@v4

      - uses: actions/setup-python@v5
        with:
          python-version: "3.11"

      - name: Instalar deps
        run: |
          python -m pip install --upgrade pip
          pip install requests

      - name: Ingestão contínua
        env:
          WC_BASE: "https://ctctech.store"
          WC_CK: ${{ secrets.WC_CK }}
          WC_CS: ${{ secrets.WC_CS }}
        run: |
          python - <<'PY'
          import os, re, time, json, random, hashlib, html, urllib.parse, requests

          WC_BASE = os.environ.get("WC_BASE","").rstrip("/")
          CK = os.environ.get("WC_CK")
          CS = os.environ.get("WC_CS")
          assert WC_BASE and CK and CS

          HDRS = [
            {"User-Agent": "Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/122 Safari/537.36", "Accept-Language":"pt-BR,pt;q=0.9"},
            {"User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120 Safari/537.36", "Accept-Language":"pt-BR,pt;q=0.9"},
            {"User-Agent": "Mozilla/5.0 (Linux; Android 11; Pixel 5) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120 Mobile Safari/537.36", "Accept-Language":"pt-BR,pt;q=0.9"},
          ]

          QUERIES = [
            "iphone 11", "smartwatch", "fone bluetooth", "notebook", "headset gamer",
            "cafeteira", "air fryer", "brinquedos educativos", "roupas femininas vestido",
            "tenis masculino esportivo", "mochila escolar", "smart tv 43",
          ]

          DOMAINS = [
            r"amazon\.(com|com\.br|br)",
            r"mercadolivre\.com\.br",
            r"shopee\.(br|com\.br)",
            r"shein\.(com|com\.br|br)",
          ]
          dom_re = re.compile(r"https?://[^\"'<>]+", re.I)

          def good(u: str) -> bool:
            u = u.lower()
            if any(x in u for x in ["accounts.", "login", "cart", "checkout", "track", "seller", "support", "help"]): return False
            return any(re.search(d, u) for d in DOMAINS)

          def duckduckgo_links(q: str):
            url = "https://html.duckduckgo.com/html/?q=" + urllib.parse.quote(q)
            r = requests.get(url, headers=random.choice(HDRS), timeout=25)
            if r.status_code!=200: return []
            hrefs = re.findall(r'href="([^"]+)"', r.text)
            out=[]
            for h in hrefs:
              h = html.unescape(h)
              if h.startswith("/"): continue
              if not h.startswith("http"): continue
              for u in re.findall(dom_re, h):
                if good(u):
                  out.append(u)
            return out

          def fetch_meta(u: str):
            try:
              r = requests.get(u, headers=random.choice(HDRS), timeout=25, allow_redirects=True)
            except Exception:
              return None
            if r.status_code>=400 or not r.text: return None
            t = r.text
            def meta(name):
              m = re.search(rf'<meta[^>]+property=["\']{re.escape(name)}["\'][^>]+content=["\']([^"\']+)["\']', t, re.I)
              if not m:
                m = re.search(rf'<meta[^>]+name=["\']{re.escape(name)}["\'][^>]+content=["\']([^"\']+)["\']', t, re.I)
              return html.unescape(m.group(1)) if m else None
            title = meta("og:title") or re.search(r"<title[^>]*>(.*?)</title>", t, re.I|re.S)
            title = title if isinstance(title, str) else (title.group(1).strip() if title else None)
            img = meta("og:image")
            desc = meta("og:description")
            price = None
            m = re.search(r'property=["\']product:price:amount["\'][^>]+content=["\']([\d\.,]+)["\']', t, re.I)
            if m: price = m.group(1).replace(".", "").replace(",", ".")
            return {"title": title, "image": img, "desc": desc, "price": price}

          def sku_from_url(u: str):
            h = hashlib.sha1(u.encode("utf-8")).hexdigest()[:16]
            return "AFF-" + h.upper()

          def create_product(u: str, meta: dict):
            sku = sku_from_url(u)
            name = (meta.get("title") or "Produto Afiliado").strip()[:200]
            short = (meta.get("desc") or "").strip()[:400]
            price = meta.get("price")
            images=[]
            if meta.get("image"):
              images=[{"src": meta["image"]}]
            payload = {
              "name": name,
              "type": "external",
              "status": "publish",
              "regular_price": str(price) if price else "",
              "external_url": u,
              "button_text": "Ver oferta",
              "short_description": short,
              "sku": sku,
              "categories": [],
              "images": images
            }
            url = f"{WC_BASE}/wp-json/wc/v3/products"
            try:
              r = requests.post(url, params={"consumer_key":CK, "consumer_secret":CS}, json=payload, timeout=30)
              if r.status_code==201:
                return True, "created"
              data = {}
              try: data = r.json()
              except Exception: pass
              if r.status_code==400 and isinstance(data, dict) and "code" in data and "sku" in (data.get("message","").lower()):
                return True, "exists"
              return False, f"{r.status_code} {data}"
            except Exception as e:
              return False, str(e)

          # main loop
          random.shuffle(QUERIES)
          max_per_run = 40
          created=0; seen=set()
          for q in QUERIES:
            links = duckduckgo_links(f"site:amazon.com.br {q}") + \
                    duckduckgo_links(f"site:mercadolivre.com.br {q}") + \
                    duckduckgo_links(f"site:shopee.com.br {q}") + \
                    duckduckgo_links(f"site:shein.com {q}") + \
                    duckduckgo_links(f"site:shein.com.br {q}")
            for u in links:
              if u in seen: continue
              seen.add(u)
              if created>=max_per_run: break
              meta = fetch_meta(u) or {}
              ok, msg = create_product(u, meta)
              if ok: created+=1
              time.sleep(random.uniform(1.0, 3.0))
            if created>=max_per_run:
              break

          print(json.dumps({"created_this_run": created, "attempted": len(seen)}, ensure_ascii=False))
          PY
