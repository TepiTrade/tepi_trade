name: ingestao-continuada

on:
  workflow_dispatch:
  schedule:
    - cron: "*/15 * * * *"  # a cada 15 min

jobs:
  run:
    runs-on: ubuntu-latest
    timeout-minutes: 50

    steps:
      - uses: actions/checkout@v4

      - uses: actions/setup-python@v5
        with:
          python-version: "3.11"

      - name: Instalar dependencias
        run: |
          python -m pip install --upgrade pip
          pip install requests python-slugify

      - name: Ingestão com imagem
        env:
          WC_BASE: ${{ secrets.WC_BASE }}   # ex: https://ctctech.store
          WC_CK:   ${{ secrets.WC_CK }}
          WC_CS:   ${{ secrets.WC_CS }}
        run: |
          python - <<'PY'
          import os, re, time, json, random, html, hashlib, urllib.parse, requests
          from slugify import slugify  # disponível se quiser usar

          BASE = os.environ["WC_BASE"].rstrip("/")
          CK   = os.environ["WC_CK"]
          CS   = os.environ["WC_CS"]

          S = requests.Session()
          S.headers.update({
            "User-Agent": "Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/122 Safari/537.36",
            "Accept-Language": "pt-BR,pt;q=0.9,en;q=0.8",
          })

          ENGINES = [
            "https://duckduckgo.com/html/?q=",
            "https://www.bing.com/search?q=",
          ]
          DOMAIN_OK = re.compile(r"(amazon\.com\.br|mercadolivre\.com\.br|shopee\.com\.br|shein\.com)", re.I)
          BAD_PATH = ("login","cart","checkout","track","seller","support","help","mailto:",
                      "account","orders","wishlist")

          def search_links(q: str):
            out = []
            for eng in ENGINES:
              url = eng + urllib.parse.quote(q + " site:amazon.com.br OR site:mercadolivre.com.br OR site:shopee.com.br OR site:shein.com")
              try:
                r = S.get(url, timeout=15)
                r.raise_for_status()
              except Exception:
                continue
              for u in re.findall(r'https?://[^"\']+', r.text):
                u = u.split("&")[0]
                if not u.startswith("http"): 
                  continue
                if any(x in u for x in BAD_PATH): 
                  continue
                if DOMAIN_OK.search(u): 
                  out.append(u)
            seen, res = set(), []
            for u in out:
              if u not in seen:
                seen.add(u); res.append(u)
            return res[:40]

          def extract_meta(url: str):
            try:
              r = S.get(url, timeout=20)
              r.raise_for_status()
            except Exception:
              return None
            t = r.text
            def m(prop):
              m = re.search(rf'<meta[^>]+property=["\']{prop}["\'][^>]+content=["\']([^"\']+)["\']', t, re.I)
              if not m:
                m = re.search(rf'<meta[^>]+name=["\']{prop}["\'][^>]+content=["\']([^"\']+)["\']', t, re.I)
              return html.unescape(m.group(1).strip()) if m else ""
            title = m("og:title") or m("twitter:title") or (re.search(r"<title>(.*?)</title>", t, re.I|re.S).group(1).strip() if re.search(r"<title>.*?</title>", t, re.I|re.S) else "")
            img   = m("og:image") or m("twitter:image")
            price = ""
            mprice = re.search(r'content=["\']R?\$?\s?(\d{1,3}(?:[\.\s]\d{3})*(?:,\d{2})?)["\'][^>]+property=["\']product:price:amount["\']', t, re.I)
            if not mprice:
              mprice = re.search(r'R\$\s?(\d{1,3}(?:[\.\s]\d{3})*(?:,\d{2})?)', t)
            if mprice:
              price = mprice.group(1).replace(".", "").replace(" ", "").replace(",", ".")
            if not title:
              return None
            return {"title": title[:180], "image": img, "price": price}

          def exists_by_sku(sku: str) -> bool:
            url = f"{BASE}/wp-json/wc/v3/products"
            try:
              r = S.get(url, params={"sku": sku, "per_page": 1, "consumer_key": CK, "consumer_secret": CS}, timeout=15)
              r.raise_for_status()
              return len(r.json()) > 0
            except Exception:
              return False

          def create_product(meta, url):
            title = meta["title"]
            img   = meta["image"]
            price = meta["price"] or "0"
            sku   = hashlib.md5(url.encode("utf-8")).hexdigest()[:12].upper()
            if exists_by_sku(sku):
              return False, "dup"

            data = {
              "name": title,
              "type": "simple",
              "status": "publish",
              "regular_price": price,
              "sku": sku,
              "external_url": url,
              "catalog_visibility": "visible",
              "short_description": f"Importado automaticamente. Fonte: {url}",
              "images": ([{"src": img}] if img else []),
              "categories": [],
              "tags": [],
            }
            api = f"{BASE}/wp-json/wc/v3/products"
            try:
              r = S.post(api, params={"consumer_key": CK, "consumer_secret": CS},
                         json=data, timeout=25)
              r.raise_for_status()
              return True, r.json().get("id")
            except Exception as e:
              return False, str(e)[:200]

          QUERIES = [
            "produto afiliado eletrônico oferta",
            "headset gamer bluetooth",
            "caixa de som portátil",
            "mouse sem fio para notebook",
            "smartwatch feminino",
          ]

          random.shuffle(QUERIES)
          created = 0
          max_per_run = 10

          for q in QUERIES:
            if created >= max_per_run:
              break
            for u in search_links(q):
              if created >= max_per_run:
                break
              meta = extract_meta(u)
              if not meta:
                continue
              ok, _ = create_product(meta, u)
              if ok:
                created += 1
              time.sleep(random.uniform(0.6, 1.6))

          print(json.dumps({"created": created}, ensure_ascii=False))
          PY
